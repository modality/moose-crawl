{"mappings":"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","sources":["src/logic.js"],"sourcesContent":["(function() {\n/**\n * Logic Variable\n */\nclass LVar {\n  constructor(id) {\n    this.id = id\n  }\n\n  toString() {\n    return this.id\n  }\n}\n\nlet lvarCounter = 0 // global counter\nfunction lvar(id) {\n  if (!id) {\n    id = `~.${lvarCounter}`\n    lvarCounter += 1\n  }\n  return new LVar(id)\n}\n\nclass ImmutableMap {\n  constructor(data = []) {\n    this.data = data // [[key, val]]\n  }\n\n  set(key, val) {\n    let find = false,\n        data = []\n    for (let i = 0; i < this.data.length; i++) {\n      const pair = this.data[i]\n      if (key !== pair[0]) {\n        data.push(pair)\n      }\n    }\n    data.push([key, val])\n    return new ImmutableMap(data)\n  }\n\n  get(key) {\n    for (let i = 0; i < this.data.length; i++) {\n      const pair = this.data[i]\n      if (key === pair[0]) return pair[1]\n    }\n    return undefined\n  }\n\n  toMap() {\n    return new Map(this.data)\n  }\n\n  pprint() {\n    console.log(this.toMap())\n  }\n\n  toString() {\n    return this.toMap().toString()\n  }\n}\n\n/*\nclass Domain {\n  constructor(min, max) {\n    this.min = min\n    this.max = max\n  }\n\n  equal(v) {\n    if (isDomain(v)) {\n      return this.min === v.min && this.max === v.max\n    } else if (typeof(v) === 'number') {\n      return v >= this.min && v <= this.max\n    } else {\n      return v === this\n    }\n  }\n\n  toNumber() {\n    if (this.min === this.max)\n      return this.min\n    else\n      return this\n  }\n}\nconst REAL_DOMAIN = new Domain(-Infinity, Infinity)\n\nfunction isDomain(x) {\n  return x && x.constructor === Domain\n}\n*/\n\nfunction isLVar(x) {\n  return x && x.constructor === LVar\n}\n\nfunction isArray(x) {\n  return x && x.constructor === Array\n}\n\nfunction pprint(x) {\n  if (x && x.constructor === ImmutableMap) {\n    x.pprint()\n  } else {\n    console.log(x)\n  }\n}\n\nconst dot = function(){}\n\n/**\n * Walk\n * x, {x=>12}        => 12\n * x, {x=>y}         => y\n * x, {x=>y, y=>13}  => 13\n * x, {y=>12}        => x\n */\nfunction walk(key, sMap) {\n  if (isLVar(key)) {\n    const val = sMap.get(key)\n    if (val === undefined) return key // not found\n    return walk(val, sMap) // continue\n  } else {\n    return key\n  }\n}\n\nfunction deepwalk(key, sMap) {\n  const val = walk(key, sMap)\n  if (isArray(val)) {\n    // return val.map((x) => deepwalk(x, sMap))\n    let o = []\n    for (let i = 0; i < val.length; i++) {\n      const x = val[i]\n      if (x === dot) {\n        const rest = deepwalk(val[i+1], sMap)\n        o = o.concat(rest)\n        break\n      } else {\n        o.push(deepwalk(x, sMap))\n      }\n    }\n    return o\n  } else {\n    return val\n  }\n}\n\n/**\n * Unify\n *\n * @params: x, y, sMap\n * @goal: make x and y equal in sMap\n *\n * x, 12, {} => {x=>12}\n * x, y, {} => {x=>y}\n * x, m, {x=>12, m=>n} => {x=>12, m=>n, n=>x}\n */\nfunction unify(x, y, sMap) {\n  x = walk(x, sMap)\n  y = walk(y, sMap)\n  const xIsLVar = isLVar(x),\n        yIsLVar = isLVar(y)\n\n  if (x === y) {\n    return sMap\n  } else if (xIsLVar) {\n    return sMap.set(x, y)\n  } else if (yIsLVar) {\n    return sMap.set(y, x)\n  } else if (isArray(x) && isArray(y)) {\n    return unifyArray(x, y, sMap)\n  } else { // failed to unify\n    return null\n  }\n}\n\n// x and y are arrays\nfunction unifyArray(x, y, sMap) {\n  if (!x.length && !y.length) return sMap\n  if (x[0] === dot) {\n    return unify(x[1], y, sMap)\n  } else if (y[0] === dot) {\n    return unify(y[1], x, sMap)\n  } else if ((x.length && !y.length) ||\n             (!x.length && y.length)) {\n    return null\n  }\n\n  const s = unify(x[0], y[0], sMap)\n  return s && unify(x.slice(1), y.slice(1), s)\n}\n\nfunction succeed() {\n  return function*(sMap) {\n    yield sMap\n  }\n}\n\nfunction fail() {\n  return function*(sMap) {\n    yield null\n  }\n}\n\n/**\n * and\n */\nfunction and(...clauses) {\n  return function*(sMap) {\n    function* helper(offset, sMap) {\n      if (offset === clauses.length) return\n\n      let clause = clauses[offset]\n      if (clause.constructor.name !== 'GeneratorFunction') {\n        clause = clause()\n      }\n\n      let gen = clause(sMap)\n      while (true) {\n        let res = gen.next(),\n            sMap = res.value\n        if (res.done) break\n        if (sMap) {\n          if (offset === clauses.length - 1) {\n            yield sMap\n          } else {\n            yield* helper(offset + 1, sMap)\n          }\n        } else {     // error\n          yield null // failed\n        }\n      }\n    }\n\n   yield* helper(0, sMap)\n  }\n}\n\n/**\n * or\n */\nfunction or(...clauses) {\n  let count = false,\n      startOffst = 0\n      solNum = 0\n  if (typeof(clauses[0]) === 'number') {\n    count = clauses[0]\n    startOffst = 1\n  }\n  return function*(sMap) {\n    function* helper(offset, sMap, solNum) {\n      if (offset === clauses.length) return\n\n      let clause = clauses[offset]\n      if (clause.constructor.name !== 'GeneratorFunction') {\n        clause = clause()\n      }\n\n      const gen = clause(sMap)\n      while (true) {\n        const res = gen.next(),\n              sMap = res.value\n        if (res.done) break\n        if (sMap) {\n          yield sMap\n          solNum++\n          if (count && solNum >= count) return\n        }\n      }\n\n      yield* helper(offset + 1, sMap, solNum)\n    }\n\n    yield* helper(startOffst, sMap, solNum)\n  }\n}\n\n/**\n * eq\n */\nfunction eq(x, y) {\n  return function*(sMap) {\n    yield unify(x, y, sMap)\n  }\n}\n\n/**\n * run\n */\nfunction run(num, vars, goal) {\n  lvarCounter = 0 // reset counter\n  if (arguments.length === 2) {\n    goal = vars\n    vars = num\n    num = -1 // get all possible results\n  }\n\n  if (goal.constructor.name !== 'GeneratorFunction') {\n    goal = goal()\n  }\n\n  if (!(vars instanceof Array)) {\n    vars = [vars]\n  }\n\n  const results = []\n  let sMap = new ImmutableMap(),\n        gen = goal(sMap)\n\n  while (num) {\n    const res = gen.next(),\n          sMap = res.value\n    if (res.done) break\n    if (sMap) {\n      num--\n      const r = {} // new Map()\n      vars.forEach((v)=> {\n        r[v] = deepwalk(v, sMap)\n      })\n      results.push(r)\n    }\n  }\n  // console.log(sMap)\n  return results\n}\n\nfunction conso(first, rest, out) {\n  if (isLVar(rest)) {\n    return eq([first, dot, rest], out)\n  } else {\n    return eq([first, ...rest], out)\n  }\n}\n\nfunction firsto(first, out) {\n  return function(rest=lvar()) {\n    return conso(first, rest, out)\n  }\n}\n\nfunction resto(rest, out) {\n  return function(first=lvar()) {\n    return conso(first, rest, out)\n  }\n}\n\nfunction emptyo(x) {\n  return eq(x, [])\n}\n\nfunction membero(x, arr) {\n  return or(\n    (first=lvar())=> and(\n      firsto(first, arr),\n      eq(first, x)\n    ),\n    (rest=lvar()) => and(\n      resto(rest, arr),\n      membero(x, rest)\n    )\n  )\n}\n\nfunction appendo(seq1, seq2, out) {\n  return or(\n    and(emptyo(seq1), eq(seq2, out)),\n    (first=lvar(), rest=lvar(), rec=lvar())=> and(\n          conso(first, rest, seq1),\n          conso(first, rec, out),\n          appendo(rest, seq2, rec)))\n}\n\n/*\n  Constraints has to be sequential\n */\n// a + b = c\nfunction add(a, b, c) {\n  return function*(sMap) {\n    let numOfLVars = 0,\n        lvar_ = null\n\n    a = walk(a, sMap)\n    b = walk(b, sMap)\n    c = walk(c, sMap)\n\n    const aIsLVar = isLVar(a),\n          bIsLVar = isLVar(b),\n          cIsLVar = isLVar(c)\n\n    if (aIsLVar) { lvar_ = a; numOfLVars++ }\n    if (bIsLVar) { lvar_ = b; numOfLVars++ }\n    if (cIsLVar) { lvar_ = c; numOfLVars++ }\n\n    if (numOfLVars === 0) {\n      if (a + b === c) yield sMap\n      else yield null\n    } else if (numOfLVars === 1) {\n      if (lvar_ === a) {\n        if (typeof(c) === 'number' && typeof(b) === 'number')\n          yield* eq(a, c - b)(sMap)\n        else\n          yield null\n      } else if (lvar_ === b) {\n        if (typeof(c) === 'number' && typeof(a) === 'number' )\n          yield* eq(b, c - a)(sMap)\n        else\n          yield null\n      } else { // c\n        if (typeof(a) === 'number' && typeof(b) === 'number')\n          yield* eq(c, a + b)(sMap)\n        else\n          yield null\n      }\n    } else {\n      yield null\n    }\n  }\n}\n\n// a - b = c\nfunction sub(a, b, c) {\n  return add(b, c, a)\n}\n\n// a * b = c\nfunction mul(a, b, c) {\n  return function*(sMap) {\n    let numOfLVars = 0,\n        lvar_ = null\n\n    a = walk(a, sMap)\n    b = walk(b, sMap)\n    c = walk(c, sMap)\n\n    if (isLVar(a)) { lvar_ = a; numOfLVars++ }\n    if (isLVar(b)) { lvar_ = b; numOfLVars++ }\n    if (isLVar(c)) { lvar_ = c; numOfLVars++ }\n\n    if (numOfLVars === 0) {\n      if (a * b === c) yield sMap\n      else yield null\n    } else if (numOfLVars === 1) {\n      if (lvar_ === a) {\n        if (typeof(c) === 'number' && typeof(b) === 'number')\n          yield* eq(a, c / b)(sMap)\n        else\n          yield null\n      } else if (lvar_ === b) {\n        if (typeof(c) === 'number' && typeof(a) === 'number' )\n          yield* eq(b, c / a)(sMap)\n        else\n          yield null\n      } else { // c\n        if (typeof(a) === 'number' && typeof(b) === 'number')\n          yield* eq(c, a * b)(sMap)\n        else\n          yield null\n      }\n    } else {\n      yield null\n    }\n  }\n}\n\n// a / b = c\nfunction div(a, b, c) {\n  return mul(b, c, a)\n}\n\nfunction lt(x, y) {\n  return function*(sMap) {\n    x = walk(x, sMap)\n    y = walk(y, sMap)\n    if (typeof(x) === 'number' && typeof(y) === 'number' && x < y) yield sMap\n    yield null\n  }\n}\n\nfunction le(x, y) {\n  return function*(sMap) {\n    x = walk(x, sMap)\n    y = walk(y, sMap)\n    if (typeof(x) === 'number' && typeof(y) === 'number' && x <= y) yield sMap\n    yield null\n  }\n}\n\nfunction gt(x, y) {\n  return lt(y, x)\n}\n\nfunction ge(x, y) {\n  return le(y, x)\n}\n\nfunction stringo(x) {\n  return function*(sMap) {\n    const val = walk(x, sMap)\n    if (typeof(val) === 'string') yield sMap\n    yield null // not of type string\n  }\n}\n\nfunction numbero(x) {\n  return function*(sMap) {\n    const val = walk(x, sMap)\n    if (typeof(val) === 'number') yield sMap\n    yield null // not of type number\n  }\n}\n\nfunction arrayo(x) {\n  return function*(sMap) {\n    const val = walk(x, sMap)\n    if (isArray(val)) yield sMap\n    yield null // not of type array\n  }\n}\n\n/**\n * fact\n */\nfunction facts(...facs) {\n return function(...args) {\n   return or.apply(null,\n                   facs.map(fac => and.apply(null,\n                                              fac.map((facArg, i)=> eq(facArg, args[i])))))\n                                            }\n}\n\nfunction anyo(goal) {\n  return or(goal, ()=> anyo(goal))\n}\n\nwindow.logic = { lvar, run, and, or, eq, facts,\n                conso, firsto, resto, emptyo, membero, appendo,\n                numbero, stringo, arrayo,\n                add, sub, mul, div,\n                lt, le, gt, ge,\n                succeed, fail,\n                anyo };\n\n}())\n"],"names":["LVar","constructor","id","this","toString","lvarCounter","lvar","ImmutableMap","data","set","key","val","i","length","pair","push","get","toMap","Map","pprint","console","log","isLVar","x","isArray","Array","dot","walk","sMap","undefined","deepwalk","o","rest","concat","unify","y","xIsLVar","yIsLVar","s","slice","unifyArray","and","clauses","sMap1","helper","offset","clause","name","gen","res","next","value","done","or","count","startOffst","solNum","sMap2","eq","conso","first","out","firsto","resto","emptyo","add","a","b","c","numOfLVars","lvar_","aIsLVar","bIsLVar","cIsLVar","mul","lt","le","window","logic","num","vars","goal","arguments","results","r","forEach","v","facs","args","apply","map","fac","facArg","membero","arr","appendo","seq1","seq2","rec","anyo"],"version":3,"file":"index.ee75c612.js.map"}